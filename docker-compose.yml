services:
  # MongoDB Database
  mongodb:
    image: mongo:7
    container_name: meshcentral-mongodb
    restart: unless-stopped
    environment:
      MONGO_INITDB_ROOT_USERNAME: ${MONGO_ROOT_USERNAME}
      MONGO_INITDB_ROOT_PASSWORD: ${MONGO_ROOT_PASSWORD}
      MONGO_INITDB_DATABASE: ${MONGO_DATABASE}
      MESHCENTRAL_USER: ${MESHCENTRAL_DB_USER}
      MESHCENTRAL_PASSWORD: ${MESHCENTRAL_DB_PASSWORD}
    volumes:
      - mongodb-data:/data/db
      - mongodb-config:/data/configdb
      - ./mongo-init/init-mongo.js:/docker-entrypoint-initdb.d/init-mongo.js:ro
    networks:
      - meshcentral-backend
    command: 
      - --auth
      # Enable encryption at rest (requires keyfile configuration in production)
      # - --enableEncryption
      # - --encryptionKeyFile=/etc/mongodb-keyfile
    healthcheck:
      test: echo 'db.runCommand("ping").ok' | mongosh localhost:27017/${MONGO_DATABASE} --quiet
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # CrowdSec Security Engine (Optional - comment out if not using)
  crowdsec:
    image: crowdsecurity/crowdsec:latest
    container_name: meshcentral-crowdsec
    restart: unless-stopped
    environment:
      # CrowdSec collections to install
      COLLECTIONS: "crowdsecurity/http-cve crowdsecurity/whitelist-good-actors crowdsecurity/iptables crowdsecurity/linux"
      # Enable metrics
      METRICS_ENABLED: "true"
    volumes:
      # CrowdSec configuration and database
      - crowdsec-config:/etc/crowdsec
      - crowdsec-data:/var/lib/crowdsec/data
      # Mount WAF logs for analysis
      - waf-logs:/var/log/nginx:ro
    networks:
      - meshcentral-backend
      - meshcentral-frontend
    healthcheck:
      test: ["CMD", "cscli", "version"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    profiles:
      - crowdsec  # Only start when explicitly enabled

  # CrowdSec Init Helper (Optional - only needed for automated setup)
  crowdsec-init:
    image: alpine:latest
    container_name: meshcentral-crowdsec-init
    depends_on:
      crowdsec:
        condition: service_healthy
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - ./scripts/init_crowdsec.sh:/init_crowdsec.sh:ro
      - ./meshcentral-data:/meshcentral-data
    environment:
      CROWDSEC_CONTAINER: ${CROWDSEC_CONTAINER:-meshcentral-crowdsec}
      CROWDSEC_BOUNCER_NAME: ${CROWDSEC_BOUNCER_NAME:-meshcentral}
      CROWDSEC_LAPI_URL: ${CROWDSEC_LAPI_URL:-http://crowdsec:8080}
    networks:
      - meshcentral-backend
      - meshcentral-frontend
    command: sh -c "apk add --no-cache docker-cli jq && sh /init_crowdsec.sh"
    profiles:
      - crowdsec-init  # Only run when explicitly enabled

  # MeshCentral Server
  meshcentral:
    image: ghcr.io/ylianst/meshcentral:latest
    container_name: meshcentral-app
    restart: unless-stopped
    depends_on:
      mongodb:
        condition: service_healthy
      crowdsec:
        condition: service_healthy
        required: false  # Optional dependency
    environment:
      # Hostname configuration
      HOSTNAME: ${MESHCENTRAL_HOSTNAME}
      # Reverse proxy settings
      REVERSE_PROXY: ${REVERSE_PROXY:-nginx}
      REVERSE_PROXY_TLS_PORT: ${REVERSE_PROXY_TLS_PORT:-443}
      # MongoDB connection
      MONGO_INITDB_ROOT_USERNAME: ${MONGO_ROOT_USERNAME}
      MONGO_INITDB_ROOT_PASSWORD: ${MONGO_ROOT_PASSWORD}
      MONGO_URL: mongodb://${MESHCENTRAL_DB_USER}:${MESHCENTRAL_DB_PASSWORD}@mongodb:27017/${MONGO_DATABASE}
      # Node settings
      NODE_ENV: ${NODE_ENV:-production}
    volumes:
      - meshcentral-data:/opt/meshcentral/meshcentral-data
      - meshcentral-files:/opt/meshcentral/meshcentral-files
      - meshcentral-backup:/opt/meshcentral/meshcentral-backup
      - meshcentral-web:/opt/meshcentral/meshcentral-web
      # Rendered config - must be generated using render-config.sh before starting
      - ./meshcentral-data/config.json:/opt/meshcentral/meshcentral-data/config.json:ro
      # User allowed IP setting - uncomment to restrict to IPs in userallowedips.txt file
      # - ./meshcentral-data/userallowedips.txt:/opt/meshcentral/meshcentral-data/userallowedips.txt:ro
    networks:
      - meshcentral-backend
      - meshcentral-frontend
    healthcheck:
      test: ["CMD", "curl", "-f", "-k", "http://127.0.0.1:4430/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s

  # WAF – nginx + ModSecurity + OWASP CRS (replaces Caddy as the default reverse proxy)
  # Traffic flow: cloudflared → waf → meshcentral
  # CrowdSec remains a sidecar and is not wired into nginx directly.
  # Tip: pin to a specific digest/tag for reproducible security-critical deployments,
  #      e.g. owasp/modsecurity-crs:nginx-alpine-4 instead of :nginx.
  #
  # All WAF behaviour is driven by environment variables; no nginx config files are
  # bind-mounted. See .env.example for the full list of WAF_ variables.
  waf:
    image: owasp/modsecurity-crs:nginx
    container_name: meshcentral-waf
    restart: unless-stopped
    depends_on:
      meshcentral:
        condition: service_healthy
    ports:
      - "${WAF_HTTP_PORT:-80}:80"
      - "${WAF_HTTPS_PORT:-443}:443"
    environment:
      # Backend: internal MeshCentral application container (protocol + host + port)
      BACKEND: ${WAF_BACKEND:-https://meshcentral:4430}
      # ModSecurity engine mode: DetectionOnly (log only) or On (actively block)
      # Note: waf/modsecurity.conf (mounted below) also sets SecRuleEngine and takes
      # precedence over this variable; keep both in sync when changing modes.
      MODSEC_RULE_ENGINE: ${WAF_MODSEC_RULE_ENGINE:-DetectionOnly}
      # Increase proxy timeouts for long-lived MeshCentral agent connections
      PROXY_TIMEOUT: ${WAF_PROXY_TIMEOUT:-3600s}
      PROXY_READ_TIMEOUT: ${WAF_PROXY_TIMEOUT:-3600s}
      PROXY_SEND_TIMEOUT: ${WAF_PROXY_TIMEOUT:-3600s}
      # TLS certificate paths inside the container.
      # To terminate TLS at the WAF (instead of relying on Cloudflare Tunnel),
      # place your certificate and key in waf/ssl/, uncomment the volume mounts
      # below, and override these variables in .env (WAF_SSL_CERT / WAF_SSL_CERT_KEY):
      SSL_CERT: ${WAF_SSL_CERT:-/etc/nginx/ssl/cert.pem}
      SSL_CERT_KEY: ${WAF_SSL_CERT_KEY:-/etc/nginx/ssl/key.pem}
    volumes:
      # ModSecurity override settings (engine mode, audit logging, etc.)
      # The OWASP CRS image already loads modsecurity.conf + CRS via setup.conf;
      # modsecurity-override.conf is the correct place for user overrides.
      # - ./waf/modsecurity.conf:/etc/modsecurity.d/modsecurity-override.conf:ro
      # Persist WAF logs; CrowdSec mounts this volume for log analysis
      - waf-logs:/var/log/nginx
      # TLS certificates for the HTTPS listener.
      # Place your files in waf/ssl/ and uncomment when terminating TLS at the WAF.
      # Set WAF_SSL_CERT / WAF_SSL_CERT_KEY in .env if you use different paths:
      # - ./waf/ssl/cert.pem:/etc/nginx/ssl/cert.pem:ro
      # - ./waf/ssl/key.pem:/etc/nginx/ssl/key.pem:ro
    networks:
      - meshcentral-frontend
    # Health check verifies that the nginx process is accepting connections.
    # End-to-end connectivity to MeshCentral is guaranteed at startup via
    # depends_on (service_healthy on the meshcentral container).
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://127.0.0.1:80/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 15s

  # Caddy Reverse Proxy (Optional – use instead of waf when automatic HTTPS via
  # Let's Encrypt / Cloudflare DNS challenge is preferred over nginx+ModSecurity)
  caddy:
    build:
      context: ./caddy
      dockerfile: Dockerfile
    container_name: meshcentral-caddy
    restart: unless-stopped
    depends_on:
      meshcentral:
        condition: service_healthy
    ports:
      - "${CADDY_HTTP_PORT:-80}:80"
      - "${CADDY_HTTPS_PORT:-443}:443"
      - "${CADDY_ADMIN_PORT:-2019}:2019"
    environment:
      ACME_EMAIL: ${ACME_EMAIL}
      CLOUDFLARE_API_TOKEN: ${CLOUDFLARE_API_TOKEN}
      MESHCENTRAL_HOSTNAME: ${MESHCENTRAL_HOSTNAME}
    volumes:
      # Caddyfile with environment variable substitution
      - ./caddy/Caddyfile:/etc/caddy/Caddyfile:ro
      - caddy-data:/data
      - caddy-config:/config
    networks:
      - meshcentral-frontend
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://127.0.0.1:2019/config/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
    profiles:
      - caddy  # Only start when explicitly enabled

  # Cloudflared Tunnel (Optional - remove if not using Cloudflare Tunnel)
  cloudflared:
    image: cloudflare/cloudflared:latest
    container_name: meshcentral-cloudflared
    restart: unless-stopped
    depends_on:
      waf:
        condition: service_healthy
    command: tunnel --no-autoupdate run --token ${CLOUDFLARE_TUNNEL_TOKEN}
    networks:
      - meshcentral-frontend
    profiles:
      - cloudflare  # Only start when explicitly enabled

networks:
  meshcentral-frontend:
    driver: bridge
    internal: false
    ipam:
      config:
        - subnet: 172.19.0.0/16
  meshcentral-backend:
    driver: bridge
    internal: true

volumes:
  mongodb-data:
    driver: local
  mongodb-config:
    driver: local
  meshcentral-data:
    driver: local
  meshcentral-files:
    driver: local
  meshcentral-backup:
    driver: local
  meshcentral-web:
    driver: local
  caddy-data:
    driver: local
  caddy-config:
    driver: local
  crowdsec-config:
    driver: local
  crowdsec-data:
    driver: local
  waf-logs:
    driver: local
